
% Default to the notebook output style

    


% Inherit from the specified cell style.




    
\documentclass[11pt]{article}

    
    
    \usepackage[T1]{fontenc}
    % Nicer default font (+ math font) than Computer Modern for most use cases
    \usepackage{mathpazo}

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % We will generate all images so they have a width \maxwidth. This means
    % that they will get their normal width if they fit onto the page, but
    % are scaled down if they would overflow the margins.
    \makeatletter
    \def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth
    \else\Gin@nat@width\fi}
    \makeatother
    \let\Oldincludegraphics\includegraphics
    % Set max figure width to be 80% of text width, for now hardcoded.
    \renewcommand{\includegraphics}[1]{\Oldincludegraphics[width=.8\maxwidth]{#1}}
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionLabelFormat{nolabel}{}
    \captionsetup{labelformat=nolabel}

    \usepackage{adjustbox} % Used to constrain images to a maximum size 
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage[utf8x]{inputenc} % Allow utf-8 characters in the tex document
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range 
    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    

    
    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatability definitions
    \def\gt{>}
    \def\lt{<}
    % Document parameters
    \title{BasicIntroduction}
    
    
    

    % Pygments definitions
    
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@fm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sa\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@dl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ch\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cpf\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % Exact colors from NB
    \definecolor{incolor}{rgb}{0.0, 0.0, 0.5}
    \definecolor{outcolor}{rgb}{0.545, 0.0, 0.0}



    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

    \begin{document}
    
    
    \maketitle
    
    

    
    \subsection{A Basic Introduction to
Julia}\label{a-basic-introduction-to-julia}

This quick introduction assumes that you have basic knowledge of some
scripting language and provides an example of the Julia syntax. So
before we explain anything, let's just treat it like a scripting
language, take a head-first dive into Julia, and see what happens.

You'll notice that, given the right syntax, almost everything will "just
work". There will be some peculiarities, and these we will be the facts
which we will study in much more depth. Usually, these
oddies/differences from other scripting languages are "the source of
Julia's power".

    \subsubsection{Problems}\label{problems}

Time to start using your noggin. Scattered in this document are problems
for you to solve using Julia. Many of the details for solving these
problems have been covered, some have not. You may need to use some
external resources:

https://docs.julialang.org/en/stable/

https://gitter.im/JuliaLang/julia

Solve as many or as few problems as you can during these times. Please
work at your own pace, or with others if that's how you're comfortable!

    \subsection{Documentation and
"Hunting"}\label{documentation-and-hunting}

The main source of information is the
\href{http://docs.julialang.org/en/latest/manual/}{Julia Documentation}.
Julia also provides lots of built-in documentation and ways to find out
what's going on. The number of tools for "hunting down what's going on /
available" is too numerous to explain in full detail here, so instead
this will just touch on what's important. For example, the ? gets you to
the documentation for a type, function, etc.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{o}{?}\PY{n}{copy}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
search: \textbf{c}\textbf{o}\textbf{p}\textbf{y} \textbf{c}\textbf{o}\textbf{p}\textbf{y}! \textbf{c}\textbf{o}\textbf{p}\textbf{y}to! \textbf{c}\textbf{o}\textbf{p}\textbf{y}sign deep\textbf{c}\textbf{o}\textbf{p}\textbf{y} unsafe\_\textbf{c}\textbf{o}\textbf{p}\textbf{y}to! \textbf{c}ircc\textbf{o}\textbf{p}\textbf{y}! \textbf{c}\textbf{o}s\textbf{p}i


    \end{Verbatim}
\texttt{\color{outcolor}Out[{\color{outcolor}1}]:}
    
    \begin{verbatim}
copy(x)
\end{verbatim}

Create a shallow copy of \texttt{x}: the outer structure is copied, but
not all internal values. For example, copying an array produces a new
array with identically-same elements as the original.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\begin{verbatim}
copy(A::Transpose)
copy(A::Adjoint)
\end{verbatim}

Eagerly evaluate the lazy matrix transpose/adjoint. Note that the
transposition is applied recursively to elements.

This operation is intended for linear algebra usage - for general data
manipulation see \href{@ref\%20Base.permutedims}{\texttt{permutedims}},
which is non-recursive.

\section{Examples}\label{examples}

\begin{verbatim}
julia> A = [1 2im; -3im 4]
2×2 Array{Complex{Int64},2}:
 1+0im  0+2im
 0-3im  4+0im

julia> T = transpose(A)
2×2 Transpose{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0-3im
 0+2im  4+0im

julia> copy(T)
2×2 Array{Complex{Int64},2}:
 1+0im  0-3im
 0+2im  4+0im
\end{verbatim}

    

    To find out what methods are available, we can use the \texttt{methods}
function. For example, let's see how \texttt{+} is defined:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{n}{methods}\PY{p}{(}\PY{o}{+}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}2}]:} \# 163 methods for generic function "+":
        [1] +(x::Bool, z::Complex\{Bool\}) in Base at complex.jl:277
        [2] +(x::Bool, y::Bool) in Base at bool.jl:104
        [3] +(x::Bool) in Base at bool.jl:101
        [4] +(x::Bool, y::T) where T<:AbstractFloat in Base at bool.jl:112
        [5] +(x::Bool, z::Complex) in Base at complex.jl:284
        [6] +(a::Float16, b::Float16) in Base at float.jl:392
        [7] +(x::Float32, y::Float32) in Base at float.jl:394
        [8] +(x::Float64, y::Float64) in Base at float.jl:395
        [9] +(z::Complex\{Bool\}, x::Bool) in Base at complex.jl:278
        [10] +(z::Complex\{Bool\}, x::Real) in Base at complex.jl:292
        [11] +(::Missing, ::Missing) in Base at missing.jl:92
        [12] +(::Missing) in Base at missing.jl:79
        [13] +(::Missing, ::Number) in Base at missing.jl:93
        [14] +(level::Base.CoreLogging.LogLevel, inc::Integer) in Base.CoreLogging at logging.jl:106
        [15] +(c::BigInt, x::BigFloat) in Base.MPFR at mpfr.jl:353
        [16] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt, e::BigInt) in Base.GMP at gmp.jl:443
        [17] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt) in Base.GMP at gmp.jl:442
        [18] +(a::BigInt, b::BigInt, c::BigInt) in Base.GMP at gmp.jl:441
        [19] +(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:412
        [20] +(x::BigInt, c::Union\{UInt16, UInt32, UInt64, UInt8\}) in Base.GMP at gmp.jl:449
        [21] +(x::BigInt, c::Union\{Int16, Int32, Int64, Int8\}) in Base.GMP at gmp.jl:455
        [22] +(a::BigFloat, b::BigFloat, c::BigFloat, d::BigFloat, e::BigFloat) in Base.MPFR at mpfr.jl:503
        [23] +(a::BigFloat, b::BigFloat, c::BigFloat, d::BigFloat) in Base.MPFR at mpfr.jl:496
        [24] +(a::BigFloat, b::BigFloat, c::BigFloat) in Base.MPFR at mpfr.jl:490
        [25] +(x::BigFloat, c::BigInt) in Base.MPFR at mpfr.jl:349
        [26] +(x::BigFloat, y::BigFloat) in Base.MPFR at mpfr.jl:318
        [27] +(x::BigFloat, c::Union\{UInt16, UInt32, UInt64, UInt8\}) in Base.MPFR at mpfr.jl:325
        [28] +(x::BigFloat, c::Union\{Int16, Int32, Int64, Int8\}) in Base.MPFR at mpfr.jl:333
        [29] +(x::BigFloat, c::Union\{Float16, Float32, Float64\}) in Base.MPFR at mpfr.jl:341
        [30] +(x::Dates.CompoundPeriod, y::Dates.CompoundPeriod) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/periods.jl:349
        [31] +(x::Dates.CompoundPeriod, y::Dates.Period) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/periods.jl:347
        [32] +(x::Dates.CompoundPeriod, y::Dates.TimeType) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/periods.jl:385
        [33] +(x::Dates.Date, y::Dates.Day) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/arithmetic.jl:78
        [34] +(x::Dates.Date, y::Dates.Week) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/arithmetic.jl:76
        [35] +(dt::Dates.Date, z::Dates.Month) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/arithmetic.jl:59
        [36] +(dt::Dates.Date, y::Dates.Year) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/arithmetic.jl:32
        [37] +(dt::Dates.Date, t::Dates.Time) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/arithmetic.jl:20
        [38] +(t::Dates.Time, dt::Dates.Date) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/arithmetic.jl:24
        [39] +(x::Dates.Time, y::Dates.TimePeriod) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/arithmetic.jl:82
        [40] +(dt::Dates.DateTime, z::Dates.Month) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/arithmetic.jl:52
        [41] +(dt::Dates.DateTime, y::Dates.Year) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/arithmetic.jl:28
        [42] +(x::Dates.DateTime, y::Dates.Period) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/arithmetic.jl:80
        [43] +(B::BitArray\{2\}, J::LinearAlgebra.UniformScaling) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/uniformscaling.jl:88
        [44] +(a::Pkg.Resolve.VersionWeights.VersionWeight, b::Pkg.Resolve.VersionWeights.VersionWeight) in Pkg.Resolve.VersionWeights at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Pkg/src/resolve/VersionWeights.jl:26
        [45] +(a::Pkg.Resolve.MaxSum.FieldValues.FieldValue, b::Pkg.Resolve.MaxSum.FieldValues.FieldValue) in Pkg.Resolve.MaxSum.FieldValues at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Pkg/src/resolve/FieldValues.jl:49
        [46] +(y::AbstractFloat, x::Bool) in Base at bool.jl:114
        [47] +(x::T, y::T) where T<:Union\{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8\} in Base at int.jl:53
        [48] +(c::Union\{UInt16, UInt32, UInt64, UInt8\}, x::BigInt) in Base.GMP at gmp.jl:450
        [49] +(c::Union\{Int16, Int32, Int64, Int8\}, x::BigInt) in Base.GMP at gmp.jl:456
        [50] +(a::Integer, b::Integer) in Base at int.jl:791
        [51] +(x::Integer, y::Ptr) in Base at pointer.jl:157
        [52] +(z::Complex, w::Complex) in Base at complex.jl:266
        [53] +(z::Complex, x::Bool) in Base at complex.jl:285
        [54] +(x::Real, z::Complex\{Bool\}) in Base at complex.jl:291
        [55] +(x::Real, z::Complex) in Base at complex.jl:303
        [56] +(z::Complex, x::Real) in Base at complex.jl:304
        [57] +(x::Rational, y::Rational) in Base at rational.jl:248
        [58] +(x::Integer, y::AbstractChar) in Base at char.jl:208
        [59] +(c::Union\{UInt16, UInt32, UInt64, UInt8\}, x::BigFloat) in Base.MPFR at mpfr.jl:329
        [60] +(c::Union\{Int16, Int32, Int64, Int8\}, x::BigFloat) in Base.MPFR at mpfr.jl:337
        [61] +(c::Union\{Float16, Float32, Float64\}, x::BigFloat) in Base.MPFR at mpfr.jl:345
        [62] +(x::AbstractIrrational, y::AbstractIrrational) in Base at irrationals.jl:133
        [63] +(x::Number) in Base at operators.jl:477
        [64] +(x::T, y::T) where T<:Number in Base at promotion.jl:411
        [65] +(x::Number, y::Number) in Base at promotion.jl:313
        [66] +(r1::OrdinalRange, r2::OrdinalRange) in Base at range.jl:978
        [67] +(r1::LinRange\{T\}, r2::LinRange\{T\}) where T in Base at range.jl:985
        [68] +(r1::StepRangeLen\{T,R,S\} where S, r2::StepRangeLen\{T,R,S\} where S) where \{R<:TwicePrecision, T\} in Base at twiceprecision.jl:554
        [69] +(r1::StepRangeLen\{T,S,S1\} where S1, r2::StepRangeLen\{T,S,S1\} where S1) where \{T, S\} in Base at range.jl:1001
        [70] +(r1::Union\{LinRange, OrdinalRange, StepRangeLen\}, r2::Union\{LinRange, OrdinalRange, StepRangeLen\}) in Base at range.jl:993
        [71] +(x::Ptr, y::Integer) in Base at pointer.jl:155
        [72] +(x::Base.TwicePrecision, y::Number) in Base at twiceprecision.jl:265
        [73] +(x::Number, y::Base.TwicePrecision) in Base at twiceprecision.jl:268
        [74] +(x::Base.TwicePrecision\{T\}, y::Base.TwicePrecision\{T\}) where T in Base at twiceprecision.jl:271
        [75] +(x::Base.TwicePrecision, y::Base.TwicePrecision) in Base at twiceprecision.jl:275
        [76] +(A::Array, Bs::Array{\ldots}) in Base at arraymath.jl:44
        [77] +(A::BitArray, B::BitArray) in Base at bitarray.jl:1074
        [78] +(A::Array\{T,2\} where T, B::LinearAlgebra.Diagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:88
        [79] +(A::Array\{T,2\} where T, B::LinearAlgebra.Bidiagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:88
        [80] +(A::Array\{T,2\} where T, B::LinearAlgebra.Tridiagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:88
        [81] +(A::Array\{T,2\} where T, B::LinearAlgebra.SymTridiagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:97
        [82] +(A::Array\{T,2\} where T, B::LinearAlgebra.AbstractTriangular) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:125
        [83] +(A::Array, B::SparseArrays.SparseMatrixCSC) in SparseArrays at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/SparseArrays/src/sparsematrix.jl:1563
        [84] +(x::Union\{DenseArray\{\#s549,N\}, ReinterpretArray\{\#s549,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\}, ReshapedArray\{\#s549,N,A,MI\} where MI<:Tuple\{Vararg\{SignedMultiplicativeInverse\{Int64\},N\} where N\} where A<:Union\{ReinterpretArray\{T,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\}, SubArray\{\#s549,N,A,I,L\} where L where I<:Tuple\{Vararg\{Union\{Int64, AbstractRange\{Int64\}, AbstractCartesianIndex\},N\} where N\} where A<:Union\{ReinterpretArray\{T,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, ReshapedArray\{T,N,A,MI\} where MI<:Tuple\{Vararg\{SignedMultiplicativeInverse\{Int64\},N\} where N\} where A<:Union\{ReinterpretArray\{T,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, DenseArray\}\} where N where \#s549<:Union\{CompoundPeriod, Period\}) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/periods.jl:358
        [85] +(X::Union\{DenseArray\{\#s549,N\}, ReinterpretArray\{\#s549,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\}, ReshapedArray\{\#s549,N,A,MI\} where MI<:Tuple\{Vararg\{SignedMultiplicativeInverse\{Int64\},N\} where N\} where A<:Union\{ReinterpretArray\{T,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\}, SubArray\{\#s549,N,A,I,L\} where L where I<:Tuple\{Vararg\{Union\{Int64, AbstractRange\{Int64\}, AbstractCartesianIndex\},N\} where N\} where A<:Union\{ReinterpretArray\{T,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, ReshapedArray\{T,N,A,MI\} where MI<:Tuple\{Vararg\{SignedMultiplicativeInverse\{Int64\},N\} where N\} where A<:Union\{ReinterpretArray\{T,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, DenseArray\}\} where N where \#s549<:Union\{CompoundPeriod, Period\}, Y::Union\{DenseArray\{\#s548,N\}, ReinterpretArray\{\#s548,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\}, ReshapedArray\{\#s548,N,A,MI\} where MI<:Tuple\{Vararg\{SignedMultiplicativeInverse\{Int64\},N\} where N\} where A<:Union\{ReinterpretArray\{T,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\}, SubArray\{\#s548,N,A,I,L\} where L where I<:Tuple\{Vararg\{Union\{Int64, AbstractRange\{Int64\}, AbstractCartesianIndex\},N\} where N\} where A<:Union\{ReinterpretArray\{T,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, ReshapedArray\{T,N,A,MI\} where MI<:Tuple\{Vararg\{SignedMultiplicativeInverse\{Int64\},N\} where N\} where A<:Union\{ReinterpretArray\{T,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, DenseArray\}\} where N where \#s548<:Union\{CompoundPeriod, Period\}) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/periods.jl:362
        [86] +(x::Union\{DenseArray\{\#s549,N\}, ReinterpretArray\{\#s549,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\}, ReshapedArray\{\#s549,N,A,MI\} where MI<:Tuple\{Vararg\{SignedMultiplicativeInverse\{Int64\},N\} where N\} where A<:Union\{ReinterpretArray\{T,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\}, SubArray\{\#s549,N,A,I,L\} where L where I<:Tuple\{Vararg\{Union\{Int64, AbstractRange\{Int64\}, AbstractCartesianIndex\},N\} where N\} where A<:Union\{ReinterpretArray\{T,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, ReshapedArray\{T,N,A,MI\} where MI<:Tuple\{Vararg\{SignedMultiplicativeInverse\{Int64\},N\} where N\} where A<:Union\{ReinterpretArray\{T,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, DenseArray\}\} where N where \#s549<:Union\{CompoundPeriod, Period\}, y::Dates.TimeType) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/arithmetic.jl:87
        [87] +(r::AbstractRange\{\#s549\} where \#s549<:Dates.TimeType, x::Dates.Period) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/ranges.jl:58
        [88] +(A::LinearAlgebra.SymTridiagonal, B::LinearAlgebra.SymTridiagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/tridiag.jl:158
        [89] +(A::LinearAlgebra.Tridiagonal, B::LinearAlgebra.Tridiagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/tridiag.jl:644
        [90] +(A::LinearAlgebra.UpperTriangular, B::LinearAlgebra.UpperTriangular) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/triangular.jl:487
        [91] +(A::LinearAlgebra.LowerTriangular, B::LinearAlgebra.LowerTriangular) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/triangular.jl:488
        [92] +(A::LinearAlgebra.UpperTriangular, B::LinearAlgebra.UnitUpperTriangular) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/triangular.jl:489
        [93] +(A::LinearAlgebra.LowerTriangular, B::LinearAlgebra.UnitLowerTriangular) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/triangular.jl:490
        [94] +(A::LinearAlgebra.UnitUpperTriangular, B::LinearAlgebra.UpperTriangular) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/triangular.jl:491
        [95] +(A::LinearAlgebra.UnitLowerTriangular, B::LinearAlgebra.LowerTriangular) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/triangular.jl:492
        [96] +(A::LinearAlgebra.UnitUpperTriangular, B::LinearAlgebra.UnitUpperTriangular) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/triangular.jl:493
        [97] +(A::LinearAlgebra.UnitLowerTriangular, B::LinearAlgebra.UnitLowerTriangular) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/triangular.jl:494
        [98] +(A::LinearAlgebra.AbstractTriangular, B::LinearAlgebra.AbstractTriangular) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/triangular.jl:495
        [99] +(Da::LinearAlgebra.Diagonal, Db::LinearAlgebra.Diagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/diagonal.jl:152
        [100] +(A::LinearAlgebra.Bidiagonal, B::LinearAlgebra.Bidiagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/bidiag.jl:304
        [101] +(UL::LinearAlgebra.UnitUpperTriangular, J::LinearAlgebra.UniformScaling) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/uniformscaling.jl:104
        [102] +(UL::LinearAlgebra.UnitLowerTriangular, J::LinearAlgebra.UniformScaling) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/uniformscaling.jl:104
        [103] +(A::SparseArrays.SparseMatrixCSC, J::LinearAlgebra.UniformScaling) in SparseArrays at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/SparseArrays/src/sparsematrix.jl:3465
        [104] +(A::AbstractArray\{T,2\} where T, J::LinearAlgebra.UniformScaling) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/uniformscaling.jl:114
        [105] +(A::LinearAlgebra.Diagonal, B::LinearAlgebra.Bidiagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:87
        [106] +(A::LinearAlgebra.Bidiagonal, B::LinearAlgebra.Diagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:88
        [107] +(A::LinearAlgebra.Diagonal, B::LinearAlgebra.Tridiagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:87
        [108] +(A::LinearAlgebra.Tridiagonal, B::LinearAlgebra.Diagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:88
        [109] +(A::LinearAlgebra.Diagonal, B::Array\{T,2\} where T) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:87
        [110] +(A::LinearAlgebra.Bidiagonal, B::LinearAlgebra.Tridiagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:87
        [111] +(A::LinearAlgebra.Tridiagonal, B::LinearAlgebra.Bidiagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:88
        [112] +(A::LinearAlgebra.Bidiagonal, B::Array\{T,2\} where T) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:87
        [113] +(A::LinearAlgebra.Tridiagonal, B::Array\{T,2\} where T) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:87
        [114] +(A::LinearAlgebra.SymTridiagonal, B::LinearAlgebra.Tridiagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:96
        [115] +(A::LinearAlgebra.Tridiagonal, B::LinearAlgebra.SymTridiagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:97
        [116] +(A::LinearAlgebra.SymTridiagonal, B::Array\{T,2\} where T) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:96
        [117] +(A::LinearAlgebra.Diagonal, B::LinearAlgebra.SymTridiagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:105
        [118] +(A::LinearAlgebra.SymTridiagonal, B::LinearAlgebra.Diagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:106
        [119] +(A::LinearAlgebra.Bidiagonal, B::LinearAlgebra.SymTridiagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:105
        [120] +(A::LinearAlgebra.SymTridiagonal, B::LinearAlgebra.Bidiagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:106
        [121] +(A::LinearAlgebra.Diagonal, B::LinearAlgebra.UpperTriangular) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:117
        [122] +(A::LinearAlgebra.UpperTriangular, B::LinearAlgebra.Diagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:118
        [123] +(A::LinearAlgebra.Diagonal, B::LinearAlgebra.UnitUpperTriangular) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:117
        [124] +(A::LinearAlgebra.UnitUpperTriangular, B::LinearAlgebra.Diagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:118
        [125] +(A::LinearAlgebra.Diagonal, B::LinearAlgebra.LowerTriangular) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:117
        [126] +(A::LinearAlgebra.LowerTriangular, B::LinearAlgebra.Diagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:118
        [127] +(A::LinearAlgebra.Diagonal, B::LinearAlgebra.UnitLowerTriangular) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:117
        [128] +(A::LinearAlgebra.UnitLowerTriangular, B::LinearAlgebra.Diagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:118
        [129] +(A::LinearAlgebra.AbstractTriangular, B::LinearAlgebra.SymTridiagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:124
        [130] +(A::LinearAlgebra.SymTridiagonal, B::LinearAlgebra.AbstractTriangular) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:125
        [131] +(A::LinearAlgebra.AbstractTriangular, B::LinearAlgebra.Tridiagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:124
        [132] +(A::LinearAlgebra.Tridiagonal, B::LinearAlgebra.AbstractTriangular) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:125
        [133] +(A::LinearAlgebra.AbstractTriangular, B::LinearAlgebra.Bidiagonal) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:124
        [134] +(A::LinearAlgebra.Bidiagonal, B::LinearAlgebra.AbstractTriangular) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:125
        [135] +(A::LinearAlgebra.AbstractTriangular, B::Array\{T,2\} where T) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/special.jl:124
        [136] +(A::SparseArrays.SparseMatrixCSC, B::SparseArrays.SparseMatrixCSC) in SparseArrays at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/SparseArrays/src/sparsematrix.jl:1559
        [137] +(A::SparseArrays.SparseMatrixCSC, B::Array) in SparseArrays at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/SparseArrays/src/sparsematrix.jl:1562
        [138] +(x::SparseArrays.AbstractSparseArray\{Tv,Ti,1\} where Ti where Tv, y::SparseArrays.AbstractSparseArray\{Tv,Ti,1\} where Ti where Tv) in SparseArrays at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/SparseArrays/src/sparsevector.jl:1290
        [139] +(x::AbstractArray\{\#s57,N\} where N where \#s57<:Number) in Base at abstractarraymath.jl:98
        [140] +(A::AbstractArray, B::AbstractArray) in Base at arraymath.jl:38
        [141] +(x::T, y::Integer) where T<:AbstractChar in Base at char.jl:207
        [142] +(index1::CartesianIndex\{N\}, index2::CartesianIndex\{N\}) where N in Base.IteratorsMD at multidimensional.jl:106
        [143] +(::Number, ::Missing) in Base at missing.jl:94
        [144] +(x::P, y::P) where P<:Dates.Period in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/periods.jl:69
        [145] +(x::Dates.Period, y::Dates.Period) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/periods.jl:346
        [146] +(y::Dates.Period, x::Dates.CompoundPeriod) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/periods.jl:348
        [147] +(x::Union\{CompoundPeriod, Period\}) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/periods.jl:357
        [148] +(x::Dates.TimeType) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/arithmetic.jl:8
        [149] +(a::Dates.TimeType, b::Dates.Period, c::Dates.Period) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/periods.jl:376
        [150] +(a::Dates.TimeType, b::Dates.Period, c::Dates.Period, d::Dates.Period{\ldots}) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/periods.jl:377
        [151] +(x::Dates.TimeType, y::Dates.CompoundPeriod) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/periods.jl:380
        [152] +(x::Dates.Instant) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/arithmetic.jl:4
        [153] +(y::Dates.Period, x::Dates.TimeType) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/arithmetic.jl:84
        [154] +(x::AbstractArray\{\#s549,N\} where N where \#s549<:Dates.TimeType, y::Union\{CompoundPeriod, Period\}) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/arithmetic.jl:86
        [155] +(x::Dates.Period, r::AbstractRange\{\#s549\} where \#s549<:Dates.TimeType) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/ranges.jl:57
        [156] +(y::Union\{CompoundPeriod, Period\}, x::AbstractArray\{\#s549,N\} where N where \#s549<:Dates.TimeType) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/arithmetic.jl:88
        [157] +(y::Dates.TimeType, x::Union\{DenseArray\{\#s549,N\}, ReinterpretArray\{\#s549,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\}, ReshapedArray\{\#s549,N,A,MI\} where MI<:Tuple\{Vararg\{SignedMultiplicativeInverse\{Int64\},N\} where N\} where A<:Union\{ReinterpretArray\{T,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\}, SubArray\{\#s549,N,A,I,L\} where L where I<:Tuple\{Vararg\{Union\{Int64, AbstractRange\{Int64\}, AbstractCartesianIndex\},N\} where N\} where A<:Union\{ReinterpretArray\{T,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, ReshapedArray\{T,N,A,MI\} where MI<:Tuple\{Vararg\{SignedMultiplicativeInverse\{Int64\},N\} where N\} where A<:Union\{ReinterpretArray\{T,N,S,A\} where S where A<:Union\{SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, SubArray\{T,N,A,I,true\} where I<:Tuple\{AbstractUnitRange,Vararg\{Any,N\} where N\} where A<:DenseArray where N where T, DenseArray\} where N where T, DenseArray\}\} where N where \#s549<:Union\{CompoundPeriod, Period\}) in Dates at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/Dates/src/arithmetic.jl:89
        [158] +(J::LinearAlgebra.UniformScaling, x::Number) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/uniformscaling.jl:82
        [159] +(x::Number, J::LinearAlgebra.UniformScaling) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/uniformscaling.jl:83
        [160] +(J1::LinearAlgebra.UniformScaling, J2::LinearAlgebra.UniformScaling) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/uniformscaling.jl:87
        [161] +(J::LinearAlgebra.UniformScaling, B::BitArray\{2\}) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/uniformscaling.jl:89
        [162] +(J::LinearAlgebra.UniformScaling, A::AbstractArray\{T,2\} where T) in LinearAlgebra at /buildworker/worker/package\_linux64/build/usr/share/julia/stdlib/v1.0/LinearAlgebra/src/uniformscaling.jl:90
        [163] +(a, b, c, xs{\ldots}) in Base at operators.jl:502
\end{Verbatim}
            
    We can inspect a type by finding its fields with \texttt{fieldnames}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{n}{fieldnames}\PY{p}{(}\PY{k+kt}{UnitRange}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}3}]:} (:start, :stop)
\end{Verbatim}
            
    and find out which method was used with the \texttt{@which} macro:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{n+nd}{@which} \PY{n}{copy}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}4}]:} copy(a::T) where T<:Array in Base at array.jl:299
\end{Verbatim}
            
    Notice that this gives you a link to the source code where the function
is defined.

    Lastly, we can find out what type a variable is with the \texttt{typeof}
function:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{n}{a} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{;}\PY{l+m+mi}{2}\PY{p}{;}\PY{l+m+mi}{3}\PY{p}{]}
        \PY{n}{typeof}\PY{p}{(}\PY{n}{a}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}5}]:} Array\{Int64,1\}
\end{Verbatim}
            
    \subsubsection{Array Syntax}\label{array-syntax}

The array syntax is similar to MATLAB's conventions.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{n}{a} \PY{o}{=} \PY{k+kt}{Vector}\PY{p}{\PYZob{}}\PY{k+kt}{Float64}\PY{p}{\PYZcb{}}\PY{p}{(}\PY{n}{undef}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{)} \PY{c}{\PYZsh{} Create a length 5 Vector (dimension 1 array) of Float64\PYZsq{}s with undefined values}
        
        \PY{n}{a} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{;}\PY{l+m+mi}{2}\PY{p}{;}\PY{l+m+mi}{3}\PY{p}{;}\PY{l+m+mi}{4}\PY{p}{;}\PY{l+m+mi}{5}\PY{p}{]} \PY{c}{\PYZsh{} Create the column vector [1 2 3 4 5]}
        
        \PY{n}{a} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1} \PY{l+m+mi}{2} \PY{l+m+mi}{3} \PY{l+m+mi}{4}\PY{p}{]} \PY{c}{\PYZsh{} Create the row vector [1 2 3 4]}
        
        \PY{n}{a}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{2} \PY{c}{\PYZsh{} Change the third element of a (using linear indexing) to 2}
        
        \PY{n}{b} \PY{o}{=} \PY{k+kt}{Matrix}\PY{p}{\PYZob{}}\PY{k+kt}{Float64}\PY{p}{\PYZcb{}}\PY{p}{(}\PY{n}{undef}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)} \PY{c}{\PYZsh{} Define a Matrix of Float64\PYZsq{}s of size (4,2) with undefined values}
        
        \PY{n}{c} \PY{o}{=} \PY{k+kt}{Array}\PY{p}{\PYZob{}}\PY{k+kt}{Float64}\PY{p}{\PYZcb{}}\PY{p}{(}\PY{n}{undef}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{7}\PY{p}{)} \PY{c}{\PYZsh{} Define a (4,5,6,7) array of Float64\PYZsq{}s with undefined values}
        
        \PY{n}{mat}    \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1} \PY{l+m+mi}{2} \PY{l+m+mi}{3} \PY{l+m+mi}{4}
                  \PY{l+m+mi}{3} \PY{l+m+mi}{4} \PY{l+m+mi}{5} \PY{l+m+mi}{6}
                  \PY{l+m+mi}{4} \PY{l+m+mi}{4} \PY{l+m+mi}{4} \PY{l+m+mi}{6}
                  \PY{l+m+mi}{3} \PY{l+m+mi}{3} \PY{l+m+mi}{3} \PY{l+m+mi}{3}\PY{p}{]} \PY{c}{\PYZsh{}Define the matrix inline }
        
        \PY{n}{mat}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{4} \PY{c}{\PYZsh{} Set element (1,2) (row 1, column 2) to 4}
        
        \PY{n}{mat}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}6}]:} 4×4 Array\{Int64,2\}:
         1  4  3  4
         3  4  5  6
         4  4  4  6
         3  3  3  3
\end{Verbatim}
            
    Note that, in the console (called the REPL), you can use \texttt{;} to
surpress the output. In a script this is done automatically. Note that
the "value" of an array is its pointer to the memory location. This
means that arrays which are set equal affect the same values:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{n}{a} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{;}\PY{l+m+mi}{3}\PY{p}{;}\PY{l+m+mi}{4}\PY{p}{]}
        \PY{n}{b} \PY{o}{=} \PY{n}{a}
        \PY{n}{b}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{10}
        \PY{n}{a}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}7}]:} 3-element Array\{Int64,1\}:
         10
          3
          4
\end{Verbatim}
            
    To set an array equal to the values to another array, use copy

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{n}{a} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{;}\PY{l+m+mi}{4}\PY{p}{;}\PY{l+m+mi}{5}\PY{p}{]}
        \PY{n}{b} \PY{o}{=} \PY{n}{copy}\PY{p}{(}\PY{n}{a}\PY{p}{)}
        \PY{n}{b}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{10}
        \PY{n}{a}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}8}]:} 3-element Array\{Int64,1\}:
         1
         4
         5
\end{Verbatim}
            
    We can also make an array of a similar size and shape via the function
\texttt{similar}, or make an array of zeros/ones with \texttt{zeros} or
\texttt{ones} respectively:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{n}{c} \PY{o}{=} \PY{n}{similar}\PY{p}{(}\PY{n}{a}\PY{p}{)}
        \PY{n}{d} \PY{o}{=} \PY{n}{zero}\PY{p}{(}\PY{n}{a}\PY{p}{)}
        \PY{n+nb}{e} \PY{o}{=} \PY{n}{ones}\PY{p}{(}\PY{n}{a}\PY{p}{)}
        \PY{n}{println}\PY{p}{(}\PY{n}{c}\PY{p}{)}\PY{p}{;} \PY{n}{println}\PY{p}{(}\PY{n}{d}\PY{p}{)}\PY{p}{;} \PY{n}{println}\PY{p}{(}\PY{n+nb}{e}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]

        MethodError: no method matching ones(::Array\{Int64,1\})
    Closest candidates are:
      ones(!Matched::Union\{Integer, AbstractUnitRange\}{\ldots}) at array.jl:463
      ones(!Matched::Type\{T\}, !Matched::Union\{Integer, AbstractUnitRange\}{\ldots}) where T at array.jl:464
      ones(!Matched::Tuple\{Vararg\{Union\{Integer, AbstractUnitRange\},N\} where N\}) at array.jl:465
      {\ldots}

        

        Stacktrace:

         [1] top-level scope at In[9]:3

    \end{Verbatim}

    Note that arrays can be index'd by arrays:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{n}{a}\PY{p}{[}\PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{2}\PY{p}{]}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}10}]:} 2-element Array\{Int64,1\}:
          1
          4
\end{Verbatim}
            
    Arrays can be of any type, specified by the type parameter. One
interesting thing is that this means that arrays can be of arrays:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{n}{a} \PY{o}{=} \PY{k+kt}{Vector}\PY{p}{\PYZob{}}\PY{k+kt}{Vector}\PY{p}{\PYZob{}}\PY{k+kt}{Float64}\PY{p}{\PYZcb{}}\PY{p}{\PYZcb{}}\PY{p}{(}\PY{n}{undef}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{)}
         \PY{n}{a}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{;}\PY{l+m+mi}{2}\PY{p}{;}\PY{l+m+mi}{3}\PY{p}{]}
         \PY{n}{a}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{;}\PY{l+m+mi}{2}\PY{p}{]}
         \PY{n}{a}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{3}\PY{p}{;}\PY{l+m+mi}{4}\PY{p}{;}\PY{l+m+mi}{5}\PY{p}{]}
         \PY{n}{a}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}11}]:} 3-element Array\{Array\{Float64,1\},1\}:
          [1.0, 2.0, 3.0]
          [1.0, 2.0]     
          [3.0, 4.0, 5.0]
\end{Verbatim}
            
    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{Question 1}\label{question-1}

Can you explain the following behavior? Julia's community values
consistancy of the rules, so all of the behavior is deducible from
simple rules. (Hint: I have noted all of the rules involved here).

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{n}{b} \PY{o}{=} \PY{n}{a}
         \PY{n}{b}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{;}\PY{l+m+mi}{4}\PY{p}{;}\PY{l+m+mi}{5}\PY{p}{]}
         \PY{n}{a}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}12}]:} 3-element Array\{Array\{Float64,1\},1\}:
          [1.0, 4.0, 5.0]
          [1.0, 2.0]     
          [3.0, 4.0, 5.0]
\end{Verbatim}
            
    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

To fix this, there is a recursive copy function: \texttt{deepcopy}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{n}{b} \PY{o}{=} \PY{n}{deepcopy}\PY{p}{(}\PY{n}{a}\PY{p}{)}
         \PY{n}{b}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{;}\PY{l+m+mi}{2}\PY{p}{;}\PY{l+m+mi}{3}\PY{p}{]}
         \PY{n}{a}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}13}]:} 3-element Array\{Array\{Float64,1\},1\}:
          [1.0, 4.0, 5.0]
          [1.0, 2.0]     
          [3.0, 4.0, 5.0]
\end{Verbatim}
            
    For high performance, Julia provides mutating functions. These functions
change the input values that are passed in, instead of returning a new
value. By convention, mutating functions tend to be defined with a
\texttt{!} at the end and tend to mutate their first argument. An
example of a mutating function in \texttt{copyto!} which copies the
values of over to the first array.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{n}{a} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{;}\PY{l+m+mi}{6}\PY{p}{;}\PY{l+m+mi}{8}\PY{p}{]}
         \PY{n}{b} \PY{o}{=} \PY{n}{similar}\PY{p}{(}\PY{n}{a}\PY{p}{)} \PY{c}{\PYZsh{} make an array just like a but with undefined values}
         \PY{n}{copyto!}\PY{p}{(}\PY{n}{b}\PY{p}{,}\PY{n}{a}\PY{p}{)} \PY{c}{\PYZsh{} b changes}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}14}]:} 3-element Array\{Int64,1\}:
          1
          6
          8
\end{Verbatim}
            
    The purpose of mutating functions is that they allow one to reduce the
number of memory allocations which is crucial for achiving high
performance.

    \subsection{Control Flow}\label{control-flow}

Control flow in Julia is pretty standard. You have your basic for and
while loops, and your if statements. There's more in the documentation.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{k}{for} \PY{n}{i}\PY{o}{=}\PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{5} \PY{c}{\PYZsh{}for i goes from 1 to 5}
             \PY{n}{println}\PY{p}{(}\PY{n}{i}\PY{p}{)}
         \PY{k}{end}
         
         \PY{n}{t} \PY{o}{=} \PY{l+m+mi}{0}
         \PY{k}{while} \PY{n}{t}\PY{o}{\PYZlt{}}\PY{l+m+mi}{5}
             \PY{n}{println}\PY{p}{(}\PY{n}{t}\PY{p}{)}
             \PY{n}{t}\PY{o}{+=}\PY{l+m+mi}{1} \PY{c}{\PYZsh{} t = t + 1}
         \PY{k}{end}
         
         \PY{n}{school} \PY{o}{=} \PY{o}{:}\PY{n}{UCI}
         
         \PY{k}{if} \PY{n}{school}\PY{o}{==}\PY{o}{:}\PY{n}{UCI}
             \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Z}\PY{l+s}{o}\PY{l+s}{t}\PY{l+s}{Z}\PY{l+s}{o}\PY{l+s}{t}\PY{l+s}{Z}\PY{l+s}{o}\PY{l+s}{t}\PY{l+s}{\PYZdq{}}\PY{p}{)}
         \PY{k}{else}
             \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{N}\PY{l+s}{o}\PY{l+s}{t}\PY{l+s}{ }\PY{l+s}{e}\PY{l+s}{v}\PY{l+s}{e}\PY{l+s}{n}\PY{l+s}{ }\PY{l+s}{w}\PY{l+s}{o}\PY{l+s}{r}\PY{l+s}{t}\PY{l+s}{h}\PY{l+s}{ }\PY{l+s}{d}\PY{l+s}{i}\PY{l+s}{s}\PY{l+s}{c}\PY{l+s}{u}\PY{l+s}{s}\PY{l+s}{s}\PY{l+s}{i}\PY{l+s}{n}\PY{l+s}{g}\PY{l+s}{.}\PY{l+s}{\PYZdq{}}\PY{p}{)}
         \PY{k}{end}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
1
2
3
4
5
0
1
2
3
4
ZotZotZot

    \end{Verbatim}

    One interesting feature about Julia control flow is that we can write
multiple loops in one line:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{k}{for} \PY{n}{i}\PY{o}{=}\PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{2}\PY{p}{,}\PY{n}{j}\PY{o}{=}\PY{l+m+mi}{2}\PY{o}{:}\PY{l+m+mi}{4}
             \PY{n}{println}\PY{p}{(}\PY{n}{i}\PY{o}{*}\PY{n}{j}\PY{p}{)}
         \PY{k}{end}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
2
3
4
4
6
8

    \end{Verbatim}

    \subsection{Problems}\label{problems}

Try the Starter Problems. If you need help, start looking through the
next parts of this tutorial!

    \subsection{Function Syntax}\label{function-syntax}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{n}{f}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)} \PY{o}{=} \PY{l+m+mi}{2}\PY{n}{x}\PY{o}{+}\PY{n}{y} \PY{c}{\PYZsh{} Create an inline function}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}17}]:} f (generic function with 1 method)
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}18}]:} \PY{n}{f}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)} \PY{c}{\PYZsh{} Call the function}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}18}]:} 4
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}19}]:} \PY{k}{function} \PY{n}{f}\PY{p}{(}\PY{n}{x}\PY{p}{)}
           \PY{n}{x}\PY{o}{+}\PY{l+m+mi}{2}  
         \PY{k}{end} \PY{c}{\PYZsh{} Long form definition}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}19}]:} f (generic function with 2 methods)
\end{Verbatim}
            
    By default, Julia functions return the last value computed within them.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}20}]:} \PY{n}{f}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}20}]:} 4
\end{Verbatim}
            
    A key feature of Julia is multiple dispatch. Notice here that there is
"one function", \texttt{f}, with two methods. Methods are the actionable
parts of a function. Here, there is one method defined as
\texttt{(::Any,::Any)} and \texttt{(::Any)}, meaning that if you give
\texttt{f} two values then it will call the first method, and if you
give it one value then it will call the second method.

Multiple dispatch works on types. To define a dispatch on a type, use
the \texttt{::Type} signifier:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}21}]:} \PY{n}{f}\PY{p}{(}\PY{n}{x}\PY{o}{::}\PY{k+kt}{Int}\PY{p}{,}\PY{n}{y}\PY{o}{::}\PY{k+kt}{Int}\PY{p}{)} \PY{o}{=} \PY{l+m+mi}{3}\PY{n}{x}\PY{o}{+}\PY{l+m+mi}{2}\PY{n}{y}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}21}]:} f (generic function with 3 methods)
\end{Verbatim}
            
    Julia will dispatch onto the strictest acceptible type signature.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}22}]:} \PY{n}{f}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{)} \PY{c}{\PYZsh{} 3x+2y}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}22}]:} 12
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}23}]:} \PY{n}{f}\PY{p}{(}\PY{l+m+mf}{2.0}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{)} \PY{c}{\PYZsh{} 2x+y since 2.0 is not an Int}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}23}]:} 7.0
\end{Verbatim}
            
    Types in signatures can be parametric. For example, we can define a
method for "two values are passed in, both Numbers and having the same
type". Note that \texttt{\textless{}:} means "a subtype of".

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}24}]:} \PY{n}{f}\PY{p}{\PYZob{}}\PY{n}{T}\PY{o}{\PYZlt{}:}\PY{k+kt}{Number}\PY{p}{\PYZcb{}}\PY{p}{(}\PY{n}{x}\PY{o}{::}\PY{n}{T}\PY{p}{,}\PY{n}{y}\PY{o}{::}\PY{n}{T}\PY{p}{)} \PY{o}{=} \PY{l+m+mi}{4}\PY{n}{x}\PY{o}{+}\PY{l+m+mi}{10}\PY{n}{y}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]

        UndefVarError: T not defined

        

        Stacktrace:

         [1] top-level scope at In[24]:1

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}25}]:} \PY{n}{f}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{)} \PY{c}{\PYZsh{} 3x+2y since (::Int,::Int) is stricter}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}25}]:} 12
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}26}]:} \PY{n}{f}\PY{p}{(}\PY{l+m+mf}{2.0}\PY{p}{,}\PY{l+m+mf}{3.0}\PY{p}{)} \PY{c}{\PYZsh{} 4x+10y}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}26}]:} 7.0
\end{Verbatim}
            
    Note that type parameterizations can have as many types as possible, and
do not need to declare a supertype. For example, we can say that there
is an \texttt{x} which must be a Number, while \texttt{y} and \texttt{z}
must match types:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}27}]:} \PY{n}{f}\PY{p}{(}\PY{n}{x}\PY{o}{::}\PY{n}{T}\PY{p}{,}\PY{n}{y}\PY{o}{::}\PY{n}{T2}\PY{p}{,}\PY{n}{z}\PY{o}{::}\PY{n}{T2}\PY{p}{)} \PY{n}{where} \PY{p}{\PYZob{}}\PY{n}{T}\PY{o}{\PYZlt{}:}\PY{k+kt}{Number}\PY{p}{,}\PY{n}{T2}\PY{p}{\PYZcb{}} \PY{o}{=} \PY{l+m+mi}{5}\PY{n}{x} \PY{o}{+} \PY{l+m+mi}{5}\PY{n}{y} \PY{o}{+} \PY{l+m+mi}{5}\PY{n}{z}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}27}]:} f (generic function with 4 methods)
\end{Verbatim}
            
    We will go into more depth on multiple dispatch later since this is the
core design feature of Julia. The key feature is that Julia functions
specialize on the types of their arguments. This means that \texttt{f}
is a separately compiled function for each method (and for parametric
types, each possible method). The first time it is called it will
compile.

    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{Question 2}\label{question-2}

Can you explain these timings?

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}28}]:} \PY{n}{f}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{z}\PY{p}{,}\PY{n}{w}\PY{p}{)} \PY{o}{=} \PY{n}{x}\PY{o}{+}\PY{n}{y}\PY{o}{+}\PY{n}{z}\PY{o}{+}\PY{n}{w}
         \PY{n+nd}{@time} \PY{n}{f}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
         \PY{n+nd}{@time} \PY{n}{f}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
         \PY{n+nd}{@time} \PY{n}{f}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
         \PY{n+nd}{@time} \PY{n}{f}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mf}{1.0}\PY{p}{)}
         \PY{n+nd}{@time} \PY{n}{f}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mf}{1.0}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
  0.002646 seconds (1.08 k allocations: 59.268 KiB)
  0.000005 seconds (4 allocations: 160 bytes)
  0.000002 seconds (4 allocations: 160 bytes)
  0.004057 seconds (5.03 k allocations: 275.235 KiB)
  0.000015 seconds (5 allocations: 176 bytes)

    \end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}28}]:} 4.0
\end{Verbatim}
            
    Note that functions can also feature optional arguments:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}29}]:} \PY{k}{function} \PY{n}{test\PYZus{}function}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{;}\PY{n}{z}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{)} \PY{c}{\PYZsh{}z is an optional argument}
           \PY{k}{if} \PY{n}{z}\PY{o}{==}\PY{l+m+mi}{0}
             \PY{k}{return} \PY{n}{x}\PY{o}{+}\PY{n}{y}\PY{p}{,}\PY{n}{x}\PY{o}{*}\PY{n}{y} \PY{c}{\PYZsh{}Return a tuple}
           \PY{k}{else}
           \PY{k}{return} \PY{n}{x}\PY{o}{*}\PY{n}{y}\PY{o}{*}\PY{n}{z}\PY{p}{,}\PY{n}{x}\PY{o}{+}\PY{n}{y}\PY{o}{+}\PY{n}{z} \PY{c}{\PYZsh{}Return a different tuple}
           \PY{c}{\PYZsh{}whitespace is optional}
           \PY{k}{end} \PY{c}{\PYZsh{}End if statement}
         \PY{k}{end} \PY{c}{\PYZsh{}End function definition}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}29}]:} test\_function (generic function with 1 method)
\end{Verbatim}
            
    Here, if z is not specified, then it's 0.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}30}]:} \PY{n}{x}\PY{p}{,}\PY{n}{y} \PY{o}{=} \PY{n}{test\PYZus{}function}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}30}]:} (3, 2)
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}31}]:} \PY{n}{x}\PY{p}{,}\PY{n}{y} \PY{o}{=} \PY{n}{test\PYZus{}function}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{;}\PY{n}{z}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}31}]:} (6, 6)
\end{Verbatim}
            
    Notice that we also featured multiple return values.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}32}]:} \PY{n}{println}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{;} \PY{n}{println}\PY{p}{(}\PY{n}{y}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
6
6

    \end{Verbatim}

    The return type for multiple return values is a Tuple. The syntax for a
tuple is \texttt{(x,y,z,...)} or inside of functions you can use the
shorthand \texttt{x,y,z,...} as shown.

Note that functions in Julia are "first-class". This means that
functions are just a type themselves. Therefore functions can make
functions, you can store functions as variables, pass them as variables,
etc. For example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}33}]:} \PY{k}{function} \PY{n}{function\PYZus{}playtime}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{c}{\PYZsh{}z is an optional argument}
             \PY{n}{y} \PY{o}{=} \PY{l+m+mi}{2}\PY{o}{+}\PY{n}{x}
             \PY{k}{function} \PY{n}{test}\PY{p}{(}\PY{p}{)}
                 \PY{l+m+mi}{2}\PY{n}{y} \PY{c}{\PYZsh{} y is defined in the previous scope, so it\PYZsq{}s available here}
             \PY{k}{end}
             \PY{n}{z} \PY{o}{=} \PY{n}{test}\PY{p}{(}\PY{p}{)} \PY{o}{*} \PY{n}{test}\PY{p}{(}\PY{p}{)}
             \PY{k}{return} \PY{n}{z}\PY{p}{,}\PY{n}{test}
         \PY{k}{end} \PY{c}{\PYZsh{}End function definition}
         \PY{n}{z}\PY{p}{,}\PY{n}{test} \PY{o}{=} \PY{n}{function\PYZus{}playtime}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}33}]:} (64, test)
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}34}]:} \PY{n}{test}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}34}]:} 8
\end{Verbatim}
            
    Notice that \texttt{test()} does not get passed in \texttt{y} but knows
what \texttt{y} is. This is due to the function scoping rules: an inner
function can know the variables defined in the same scope as the
function. This rule is recursive, leading us to the conclusion that the
top level scope is global. Yes, that means

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}35}]:} \PY{n}{a} \PY{o}{=} \PY{l+m+mi}{2}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}35}]:} 2
\end{Verbatim}
            
    defines a global variable. We will go into more detail on this.

    Lastly we show the anonymous function syntax. This allows you to define
a function inline.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}36}]:} \PY{n}{g} \PY{o}{=} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{l+m+mi}{2}\PY{n}{x}\PY{o}{+}\PY{n}{y}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}36}]:} \#5 (generic function with 1 method)
\end{Verbatim}
            
    Unlike named functions, \texttt{g} is simply a function in a variable
and can be overwritten at any time:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}37}]:} \PY{n}{g} \PY{o}{=} \PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{l+m+mi}{2}\PY{n}{x}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}37}]:} \#7 (generic function with 1 method)
\end{Verbatim}
            
    An anonymous function cannot have more than 1 dispatch. However, as of
v0.5, they are compiled and thus do not have any performance
disadvantages from named functions.

    \subsection{Type Declaration Syntax}\label{type-declaration-syntax}

A type is what in many other languages is an "object". If that is a
foreign concept, thing of a type as a thing which has named components.
A type is the idea for what the thing is, while an instantiation of the
type is a specific one. For example, you can think of a car as having an
make and a model. So that means a Toyota RAV4 is an instantiation of the
car type.

In Julia, we would define the car type as follows:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}38}]:} \PY{n}{mutable} \PY{n}{struct} \PY{n}{Car}
             \PY{n}{make}
             \PY{n}{model}
         \PY{k}{end}
\end{Verbatim}


    We could then make the instance of a car as follows:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}39}]:} \PY{n}{mycar} \PY{o}{=} \PY{n}{Car}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{T}\PY{l+s}{o}\PY{l+s}{y}\PY{l+s}{o}\PY{l+s}{t}\PY{l+s}{a}\PY{l+s}{\PYZdq{}}\PY{p}{,}\PY{l+s}{\PYZdq{}}\PY{l+s}{R}\PY{l+s}{a}\PY{l+s}{v}\PY{l+s}{4}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}39}]:} Car("Toyota", "Rav4")
\end{Verbatim}
            
    Here I introduced the string syntax for Julia which uses "..." (like
most other languages, I'm glaring at you MATLAB). I can grab the
"fields" of my type using the \texttt{.} syntax:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}40}]:} \PY{n}{mycar}\PY{o}{.}\PY{n}{make}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}40}]:} "Toyota"
\end{Verbatim}
            
    To "enhance Julia's performance", one usually likes to make the typing
stricter. For example, we can define a WorkshopParticipant (notice the
convention for types is capital letters, CamelCase) as having a name and
a field. The name will be a string and the field will be a Symbol type,
(defined by :Symbol, which we will go into plenty more detail later).

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}41}]:} \PY{n}{mutable} \PY{n}{struct} \PY{n}{WorkshopParticipant}
             \PY{n}{name}\PY{o}{::}\PY{n}{String}
             \PY{n}{field}\PY{o}{::}\PY{k+kt}{Symbol}
         \PY{k}{end}
         \PY{n}{tony} \PY{o}{=} \PY{n}{WorkshopParticipant}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{T}\PY{l+s}{o}\PY{l+s}{n}\PY{l+s}{y}\PY{l+s}{\PYZdq{}}\PY{p}{,}\PY{o}{:}\PY{n}{physics}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}41}]:} WorkshopParticipant("Tony", :physics)
\end{Verbatim}
            
    As with functions, types can be set "parametrically". For example, we
can have an StaffMember have a name and a field, but also an age. We can
allow this age to be any Number type as follows:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}42}]:} \PY{n}{mutable} \PY{n}{struct} \PY{n}{StaffMember}\PY{p}{\PYZob{}}\PY{n}{T}\PY{o}{\PYZlt{}:}\PY{k+kt}{Number}\PY{p}{\PYZcb{}}
             \PY{n}{name}\PY{o}{::}\PY{n}{String}
             \PY{n}{field}\PY{o}{::}\PY{k+kt}{Symbol}
             \PY{n}{age}\PY{o}{::}\PY{n}{T}
         \PY{k}{end}
         \PY{n}{ter} \PY{o}{=} \PY{n}{StaffMember}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{T}\PY{l+s}{e}\PY{l+s}{r}\PY{l+s}{r}\PY{l+s}{y}\PY{l+s}{\PYZdq{}}\PY{p}{,}\PY{o}{:}\PY{n}{football}\PY{p}{,}\PY{l+m+mi}{17}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}42}]:} StaffMember\{Int64\}("Terry", :football, 17)
\end{Verbatim}
            
    The rules for parametric typing is the same as for functions. Note that
most of Julia's types, like Float64 and Int, are natively defined in
Julia in this manner. This means that there's no limit for user defined
types, only your imagination. Indeed, many of Julia's features first
start out as a prototyping package before it's ever moved into Base (the
Julia library that ships as the Base module in every installation).

Lastly, there exist abstract types. These types cannot be instantiated
but are used to build the type hierarchy. You've already seen one
abstract type, Number. We can define one for Person using the Abstract
keyword

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}43}]:} \PY{k}{abstract} \PY{k}{type} \PY{n}{Person}
         \PY{k}{end}
\end{Verbatim}


    Then we can set types as a subtype of person

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}44}]:} \PY{n}{mutable} \PY{n}{struct} \PY{n}{Student} \PY{o}{\PYZlt{}:} \PY{n}{Person}
             \PY{n}{name}
             \PY{n}{grade}
         \PY{k}{end}
\end{Verbatim}


    You can define type heirarchies on abstract types. See the beautiful
explanation at:
http://docs.julialang.org/en/release-0.5/manual/types/\#abstract-types

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}45}]:} \PY{k}{abstract} \PY{k}{type} \PY{n}{AbstractStudent} \PY{o}{\PYZlt{}:} \PY{n}{Person}
         \PY{k}{end}
\end{Verbatim}


    Another "version" of type is \texttt{immutable}. When one uses
\texttt{immutable}, the fields of the type cannot be changed. However,
Julia will automatically stack allocate immutable types, whereas
standard types are heap allocated. If this is unfamiliar terminology,
then think of this as meaning that immutable types are able to be stored
closer to the CPU and have less cost for memory access (this is a detail
not present in many scripting languages). Many things like Julia's
built-in Number types are defined as \texttt{immutable} in order to give
good performance.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}46}]:} \PY{n}{struct} \PY{n}{Field}
             \PY{n}{name}
             \PY{n}{school}
         \PY{k}{end}
         \PY{n}{ds} \PY{o}{=} \PY{n}{Field}\PY{p}{(}\PY{o}{:}\PY{n}{DataScience}\PY{p}{,}\PY{p}{[}\PY{o}{:}\PY{n}{PhysicalScience}\PY{p}{;}\PY{o}{:}\PY{n}{ComputerScience}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}46}]:} Field(:DataScience, Symbol[:PhysicalScience, :ComputerScience])
\end{Verbatim}
            
    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{Question 3}\label{question-3}

Can you explain this interesting quirk? Thus Field is immutable, meaning
that \texttt{ds.name} and \texttt{ds.school} cannot be changed:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}47}]:} \PY{n}{ds}\PY{o}{.}\PY{n}{name} \PY{o}{=} \PY{o}{:}\PY{n}{ComputationalStatistics}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]

        type Field is immutable

        

        Stacktrace:

         [1] setproperty!(::Field, ::Symbol, ::Symbol) at ./sysimg.jl:19

         [2] top-level scope at In[47]:1

    \end{Verbatim}

    However, the following is allowed:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}48}]:} \PY{n}{push!}\PY{p}{(}\PY{n}{ds}\PY{o}{.}\PY{n}{school}\PY{p}{,}\PY{o}{:}\PY{n}{BiologicalScience}\PY{p}{)}
         \PY{n}{ds}\PY{o}{.}\PY{n}{school}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}48}]:} 3-element Array\{Symbol,1\}:
          :PhysicalScience  
          :ComputerScience  
          :BiologicalScience
\end{Verbatim}
            
    (Hint: recall that an array is not the values itself, but a pointer to
the memory of the values)

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

    One important detail in Julia is that everything is a type (and every
piece of code is an Expression type, more on this later). Thus functions
are also types, which we can access the fields of. Not only is
everything compiled down to native, but all of the "native parts" are
always accessible. For example, we can, if we so choose, get a function
pointer:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}49}]:} \PY{n}{foo}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{o}{=} \PY{l+m+mi}{2}\PY{n}{x}
         \PY{n}{cfunction}\PY{p}{(}\PY{n}{foo}\PY{p}{,} \PY{k+kt}{Int}\PY{p}{,} \PY{k+kt}{Tuple}\PY{p}{\PYZob{}}\PY{k+kt}{Int}\PY{p}{\PYZcb{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]

        UndefVarError: cfunction not defined

        

        Stacktrace:

         [1] top-level scope at In[49]:2

    \end{Verbatim}

    \subsection{Some Basic Types}\label{some-basic-types}

Julia provides many basic types. Indeed, you will come to know Julia as
a system of multiple dispatch on types, meaning that the interaction of
types with functions is core to the design.

\subsubsection{Lazy Iterator Types}\label{lazy-iterator-types}

While MATLAB or Python has easy functions for building arrays, Julia
tends to side-step the actual "array" part with specially made types.
One such example are ranges. To define a range, use the
\texttt{start:stepsize:end} syntax. For example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}50}]:} \PY{n}{a} \PY{o}{=} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{5}
         \PY{n}{println}\PY{p}{(}\PY{n}{a}\PY{p}{)}
         \PY{n}{b} \PY{o}{=} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{2}\PY{o}{:}\PY{l+m+mi}{10}
         \PY{n}{println}\PY{p}{(}\PY{n}{b}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
1:5
1:2:9

    \end{Verbatim}

    We can use them like any array. For example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}51}]:} \PY{n}{println}\PY{p}{(}\PY{n}{a}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}\PY{p}{;} \PY{n}{println}\PY{p}{(}\PY{n}{b}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
2
5

    \end{Verbatim}

    But what is \texttt{b}?

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}52}]:} \PY{n}{println}\PY{p}{(}\PY{n}{typeof}\PY{p}{(}\PY{n}{b}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
StepRange\{Int64,Int64\}

    \end{Verbatim}

    \texttt{b} isn't an array, it's a StepRange. A StepRange has the ability
to act like an array using its fields:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}53}]:} \PY{n}{fieldnames}\PY{p}{(}\PY{k+kt}{StepRange}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}53}]:} (:start, :step, :stop)
\end{Verbatim}
            
    Note that at any time we can get the array from these kinds of type via
the \texttt{collect} function:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}54}]:} \PY{n}{c} \PY{o}{=} \PY{n}{collect}\PY{p}{(}\PY{n}{a}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}54}]:} 5-element Array\{Int64,1\}:
          1
          2
          3
          4
          5
\end{Verbatim}
            
    The reason why lazy iterator types are preferred is that they do not do
the computations until it's absolutely necessary, and they take up much
less space. We can check this with \texttt{@time}:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}55}]:} \PY{n+nd}{@time} \PY{n}{a} \PY{o}{=} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{100000}
         \PY{n+nd}{@time} \PY{n}{a} \PY{o}{=} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{100}
         \PY{n+nd}{@time} \PY{n}{b} \PY{o}{=} \PY{n}{collect}\PY{p}{(}\PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{100000}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
  0.000004 seconds (5 allocations: 192 bytes)
  0.000003 seconds (5 allocations: 192 bytes)
  0.001093 seconds (7 allocations: 781.516 KiB)

    \end{Verbatim}

    Notice that the amount of time the range takes is much shorter. This is
mostly because there is a lot less memory allocation needed: only a
\texttt{StepRange} is built, and all that holds is the three numbers.
However, \texttt{b} has to hold \texttt{100000} numbers, leading to the
huge difference.

    \subsubsection{Dictionaries}\label{dictionaries}

Another common type is the Dictionary. It allows you to access
(key,value) pairs in a named manner. For example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}56}]:} \PY{n}{d} \PY{o}{=} \PY{k+kt}{Dict}\PY{p}{(}\PY{o}{:}\PY{n}{test}\PY{o}{=\PYZgt{}}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+s}{\PYZdq{}}\PY{l+s}{s}\PY{l+s}{i}\PY{l+s}{l}\PY{l+s}{l}\PY{l+s}{y}\PY{l+s}{\PYZdq{}}\PY{o}{=\PYZgt{}}\PY{o}{:}\PY{n}{suit}\PY{p}{)}
         \PY{n}{println}\PY{p}{(}\PY{n}{d}\PY{p}{[}\PY{o}{:}\PY{n}{test}\PY{p}{]}\PY{p}{)}
         \PY{n}{println}\PY{p}{(}\PY{n}{d}\PY{p}{[}\PY{l+s}{\PYZdq{}}\PY{l+s}{s}\PY{l+s}{i}\PY{l+s}{l}\PY{l+s}{l}\PY{l+s}{y}\PY{l+s}{\PYZdq{}}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
2
suit

    \end{Verbatim}

    \subsubsection{Tuples}\label{tuples}

Tuples are immutable arrays. That means they can't be changed. However,
they are super fast. They are made with the \texttt{(x,y,z,...)} syntax
and are the standard return type of functions which return more than one
object.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}57}]:} \PY{n}{tup} \PY{o}{=} \PY{p}{(}\PY{l+m+mf}{2.}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{)} \PY{c}{\PYZsh{} Don\PYZsq{}t have to match types}
         \PY{n}{x}\PY{p}{,}\PY{n}{y} \PY{o}{=} \PY{p}{(}\PY{l+m+mf}{3.0}\PY{p}{,}\PY{l+s}{\PYZdq{}}\PY{l+s}{h}\PY{l+s}{i}\PY{l+s}{\PYZdq{}}\PY{p}{)} \PY{c}{\PYZsh{} Can separate a tuple to multiple variables}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}57}]:} (3.0, "hi")
\end{Verbatim}
            
    \subsection{Problems}\label{problems}

Try problems 8-11 in the Basic Problems

    \subsection{Metaprogramming}\label{metaprogramming}

Metaprogramming is a huge feature of Julia. The key idea is that every
statement in Julia is of the type \texttt{Expression}. Julia operators
by building an Abstract Syntax Tree (AST) from the Expressions. You've
already been exposed to this a little bit: a \texttt{Symbol} (like
\texttt{:PhysicalSciences} is not a string because it is part of the
AST, and thus is part of the parsing/expression structure. One
interesting thing is that symbol comparisons are O(1) while string
comparisons, like always, are O(n)) is part of this, and macros (the
weird functions with an \texttt{@}) are functions on expressions.

Thus you can think of metaprogramming as "code which takes in code and
outputs code". One basic example is the \texttt{@time} macro:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}58}]:} \PY{k}{macro} \PY{n}{my\PYZus{}time}\PY{p}{(}\PY{n}{ex}\PY{p}{)}
           \PY{k}{return} \PY{k}{quote}
             \PY{k+kd}{local} \PY{n}{t0} \PY{o}{=} \PY{n}{time}\PY{p}{(}\PY{p}{)}
             \PY{k+kd}{local} \PY{n}{val} \PY{o}{=} \PY{o}{\PYZdl{}}\PY{n}{ex}
             \PY{k+kd}{local} \PY{n}{t1} \PY{o}{=} \PY{n}{time}\PY{p}{(}\PY{p}{)}
             \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{e}\PY{l+s}{l}\PY{l+s}{a}\PY{l+s}{p}\PY{l+s}{s}\PY{l+s}{e}\PY{l+s}{d}\PY{l+s}{ }\PY{l+s}{t}\PY{l+s}{i}\PY{l+s}{m}\PY{l+s}{e}\PY{l+s}{:}\PY{l+s}{ }\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{t1}\PY{o}{\PYZhy{}}\PY{n}{t0}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{ }\PY{l+s}{s}\PY{l+s}{e}\PY{l+s}{c}\PY{l+s}{o}\PY{l+s}{n}\PY{l+s}{d}\PY{l+s}{s}\PY{l+s}{\PYZdq{}}\PY{p}{)}
             \PY{n}{val}
           \PY{k}{end}
         \PY{k}{end}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}58}]:} @my\_time (macro with 1 method)
\end{Verbatim}
            
    This takes in an expression \texttt{ex}, gets the time before and after
evaluation, and prints the elapsed time between (the real time macro
also calculates the allocations as seen earlier). Note that
\texttt{\$ex} "interpolates" the expression into the macro. Going into
detail on metaprogramming is a large step from standard scripting and
will be a later session.

Why macros? One reason is because it lets you define any syntax you
want. Since it operates on the expressions themselves, as long as you
know how to parse the expression into working code, you can "choose any
syntax" to be your syntax. A case study will be shown later. Another
reason is because these are done at "parse time" and those are only
called once (before the function compilation).

    \subsection{Steps for Julia Parsing and
Execution}\label{steps-for-julia-parsing-and-execution}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The AST after parsing \textless{}- Macros
\item
  The AST after lowering (@code\_typed)
\item
  The AST after type inference and optimization \textless{}- Generated
  Functions (@code\_lowered)
\item
  The LLVM IR \textless{}- Functions (@code\_llvm)
\item
  The assembly code (@code\_native)
\end{enumerate}


    % Add a bibliography block to the postdoc
    
    
    
    \end{document}
